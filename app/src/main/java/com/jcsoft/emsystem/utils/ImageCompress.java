package com.jcsoft.emsystem.utils;import android.content.ContentResolver;import android.content.Context;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import android.net.Uri;import android.provider.MediaStore;import android.widget.Toast;import com.jcsoft.emsystem.constants.AppConfig;import java.io.BufferedOutputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;/** * 图片处理类 * Created by huwei on 2014/10/22. */public class ImageCompress {    public static final String CONTENT = "content";    public static final String FILE = "file";    /**     * 图片压缩参数     *     * @author Administrator     */    public static class CompressOptions {        public int maxWidth = 480;        public int maxHeight = 800;        /**         * 压缩后图片保存的文件         */        public File destFile;        /**         * 图片压缩格式,默认为jpg格式         */        public Bitmap.CompressFormat imgFormat = Bitmap.CompressFormat.JPEG;        /**         * 图片压缩比例 默认为30         */        public int quality = 30;        public String uri;    }    public Bitmap compressFromUriForPhoto(Context context, CompressOptions compressOptions) {        String filePath = compressOptions.uri;        if (null == filePath) {            return null;        }        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        int actualWidth = options.outWidth;        int actualHeight = options.outHeight;        int desiredWidth = getResizedDimension(compressOptions.maxWidth,                compressOptions.maxHeight, actualWidth, actualHeight);        int desiredHeight = getResizedDimension(compressOptions.maxHeight,                compressOptions.maxWidth, actualHeight, actualWidth);        options.inJustDecodeBounds = false;        options.inSampleSize = 4; //因为下面BitmapFactory.decodeFile(filePath, options)内存溢出，这里暂时先改为4        Bitmap bitmap = null;        Bitmap destBitmap = null;        try {            destBitmap = BitmapFactory.decodeFile(filePath, options);        } catch (Exception e) {            e.printStackTrace();        }        if (null == destBitmap) {            Toast.makeText(context, "拍照出错啦，请重新拍照", Toast.LENGTH_SHORT).show();            return null;        }        // If necessary, scale down to the maximal acceptable size.        if (destBitmap.getWidth() > desiredWidth || destBitmap.getHeight() > desiredHeight) {            bitmap = Bitmap.createScaledBitmap(destBitmap, desiredWidth, desiredHeight, true);            destBitmap.recycle();        } else {            bitmap = destBitmap;            destBitmap.recycle();        }        return bitmap;    }    public Bitmap compressFromUri(Context context, CompressOptions compressOptions) {        // uri指向的文件路径        String filePath = compressOptions.uri;        if (null == filePath) {            return null;        }        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        Bitmap temp = BitmapFactory.decodeFile(filePath, options);        int actualWidth = options.outWidth;        int actualHeight = options.outHeight;        int desiredWidth = getResizedDimension(compressOptions.maxWidth,                compressOptions.maxHeight, actualWidth, actualHeight);        int desiredHeight = getResizedDimension(compressOptions.maxHeight,                compressOptions.maxWidth, actualHeight, actualWidth);        options.inJustDecodeBounds = false;        options.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);        Bitmap bitmap = null;        Bitmap destBitmap = null;        try {            destBitmap = BitmapFactory.decodeFile(filePath, options);            // If necessary, scale down to the maximal acceptable size.            if (destBitmap.getWidth() > desiredWidth || destBitmap.getHeight() > desiredHeight) {                bitmap = Bitmap.createScaledBitmap(destBitmap, desiredWidth, desiredHeight, true);                destBitmap.recycle();            } else {                bitmap = destBitmap;            }            // compress file if need           /* if (null != compressOptions.destFile) {                compressFile(compressOptions, bitmap);            }*/        } catch (Exception e) {            e.printStackTrace();        }        return bitmap;    }    /**     * 先按照尺寸压缩**     */    public Bitmap getimage(String srcPath) {        BitmapFactory.Options newOpts = new BitmapFactory.Options();        //开始读入图片，此时把options.inJustDecodeBounds 设回true了        newOpts.inJustDecodeBounds = true;        Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);//此时返回bm为空        newOpts.inJustDecodeBounds = false;        int w = newOpts.outWidth;        int h = newOpts.outHeight;        //现在主流手机比较多是800*480分辨率，所以高和宽我们设置为        float hh = 800f;//这里设置高度为800f        float ww = 480f;//这里设置宽度为480f        //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可        int be = 1;//be=1表示不缩放        if (w > h && w > ww) {//如果宽度大的话根据宽度固定大小缩放            be = (int) (newOpts.outWidth / ww);        } else if (w < h && h > hh) {//如果高度高的话根据宽度固定大小缩放            be = (int) (newOpts.outHeight / hh);        }        if (be <= 0)            be = 1;        newOpts.inSampleSize = be;//设置缩放比例        //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了        bitmap = BitmapFactory.decodeFile(srcPath, newOpts);        return bitmap;//压缩好比例大小后再进行质量压缩    }    /**     * 调整尺寸后返回bitmap     *     * @param srcPath     * @param ww     * @param hh     * @return     */    public Bitmap getBitMap(String srcPath, int ww, int hh) {        BitmapFactory.Options newOpts = new BitmapFactory.Options();        //开始读入图片，此时把options.inJustDecodeBounds 设回true了        newOpts.inJustDecodeBounds = true;        Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);//此时返回bm为空        newOpts.inJustDecodeBounds = false;        int w = newOpts.outWidth;        int h = newOpts.outHeight;        //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可        int be = 1;//be=1表示不缩放        if (w > h && w > ww) {//如果宽度大的话根据宽度固定大小缩放            be = (int) (newOpts.outWidth / ww);        } else if (w < h && h > hh) {//如果高度高的话根据宽度固定大小缩放            be = (int) (newOpts.outHeight / hh);        }        if (be <= 0)            be = 1;        newOpts.inSampleSize = be;//设置缩放比例        //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了        bitmap = BitmapFactory.decodeFile(srcPath, newOpts);        return bitmap;//压缩好比例大小后再进行质量压缩    }    /**     * compress file from bitmap with compressOptions     *     * @param compressOptions     * @param bitmap     */    private void compressFile(CompressOptions compressOptions, Bitmap bitmap) {        OutputStream stream = null;        try {            stream = new FileOutputStream(compressOptions.destFile);        } catch (FileNotFoundException e) {        }        bitmap.compress(compressOptions.imgFormat, compressOptions.quality, stream);    }    private static int findBestSampleSize(int actualWidth, int actualHeight,                                          int desiredWidth, int desiredHeight) {        double wr = (double) actualWidth / desiredWidth;        double hr = (double) actualHeight / desiredHeight;        double ratio = Math.min(wr, hr);        float n = 1.0f;        while ((n * 2) <= ratio) {            n *= 2;        }        return (int) n;    }    private static int getResizedDimension(int maxPrimary, int maxSecondary, int actualPrimary, int actualSecondary) {        // If no dominant value at all, just return the actual.        if (maxPrimary == 0 && maxSecondary == 0) {            return actualPrimary;        }        // If primary is unspecified, scale primary to match secondary's scaling        // ratio.        if (maxPrimary == 0) {            double ratio = (double) maxSecondary / (double) actualSecondary;            return (int) (actualPrimary * ratio);        }        if (maxSecondary == 0) {            return maxPrimary;        }        double ratio = (double) actualSecondary / (double) actualPrimary;        int resized = maxPrimary;        if (resized * ratio > maxSecondary) {            resized = (int) (maxSecondary / ratio);        }        return resized;    }    public boolean compressAndGenImage(Bitmap image,String originalPath, String outPath, int maxSize) throws IOException {        try {            //拍照后有些照片会自动旋转，先对其进行处理            File file = new File(originalPath);            int degree = ImageUtils.readPictureDegree(file.getAbsolutePath());            image = ImageUtils.rotaingImageView(degree,image);            ByteArrayOutputStream os = new ByteArrayOutputStream();            // scale            int options = 100;            // Store the bitmap into output stream(no compress)            image.compress(Bitmap.CompressFormat.JPEG, options, os);            // Compress by loop            while (os.toByteArray().length / 1024 > maxSize) {                // Clean up os                os.reset();                // interval 10                options -= 10;                image.compress(Bitmap.CompressFormat.JPEG, options, os);            }            // Generate compressed image file            File dir = new File(AppConfig.compressedImage);            if (!dir.exists()) {                dir.mkdirs();            }            FileOutputStream fos = new FileOutputStream(outPath);            fos.write(os.toByteArray());            fos.flush();            fos.close();            return true;        } catch (Exception e) {            e.printStackTrace();        }        return false;    }    /**     * 图片压缩并保存     *     * @param image     * @param file     * @return     * @throws IOException     */    public boolean compressBmpToFile(Bitmap image, File file) throws IOException {        try {            ByteArrayOutputStream os = new ByteArrayOutputStream();            // scale            int options = 100;            // Store the bitmap into output stream(no compress)            image.compress(Bitmap.CompressFormat.JPEG, options, os);            // Compress by loop            while (os.toByteArray().length / 1024 > 100) {                // Clean up os                os.reset();                // interval 10                options -= 10;                image.compress(Bitmap.CompressFormat.JPEG, options, os);            }            // Generate compressed image file            FileOutputStream fos = new FileOutputStream(file);            fos.write(os.toByteArray());            fos.flush();            fos.close();            if (file.exists()) {//判断新的图片是否保存成功了                return true;            } else {                return false;            }        } catch (Exception e) {            e.printStackTrace();            return false;        }    }    /**     * 图片缩放     *     * @param originalBitmap 原始的Bitmap     * @param newWidth       自定义宽度     * @param newHeight      自定义高度     * @return 缩放后的Bitmap     */    public static Bitmap resizeImage(Bitmap originalBitmap, int newWidth, int newHeight) {        Bitmap resizedBitmap = null;        try {            int width = originalBitmap.getWidth();            int height = originalBitmap.getHeight();            //定义欲转换成的宽、高           /*int newWidth = 200;            int newHeight = 200;*/            //计算宽、高缩放率            float scanleWidth = (float) newWidth / width;            float scanleHeight = (float) newHeight / height;            //创建操作图片用的matrix对象 Matrix            Matrix matrix = new Matrix();            // 缩放图片动作            matrix.postScale(scanleWidth, scanleHeight);            //旋转图片 动作            //matrix.postRotate(45);            // 创建新的图片Bitmap            return Bitmap.createBitmap(originalBitmap, 0, 0, width, height, matrix, true);        } catch (Exception e) {            e.printStackTrace();        }        return null;    }    /**     * 保存图片到存储卡上 <100k     *     * @param path     路径     * @param fileName such as: 1.jpg     * @param bitmap     * @param quality     * @return     */    public static File saveBitmapToSDcard(String path, String fileName, Bitmap bitmap, int quality) {        String imagePath = path + fileName;        File file = null;        FileOutputStream out = null;        File dirFile = new File(path);        if (!dirFile.exists()) {            dirFile.mkdirs();        }        try {            file = new File(imagePath);            if (!file.exists()) {                file.createNewFile();            }            out = new FileOutputStream(file);            ByteArrayOutputStream os = new ByteArrayOutputStream();            // scale            int options = 100;            // Store the bitmap into output stream(no compress)            bitmap.compress(Bitmap.CompressFormat.JPEG, options, os);            // Compress by loop            while (os.toByteArray().length / 1024 > 200) {                // Clean up os                os.reset();                // interval 10                options -= 10;                bitmap.compress(Bitmap.CompressFormat.JPEG, options, os);            }            out.write(os.toByteArray());            out.flush();            out.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (out != null) {                try {                    out.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return file;    }    /**     * 转换图片成圆形     *     * @param bitmap 传入Bitmap对象     * @return     */    public static Bitmap toRoundBitmap(Bitmap bitmap) {        int width = bitmap.getWidth();        int height = bitmap.getHeight();        float roundPx;        float left, top, right, bottom, dst_left, dst_top, dst_right, dst_bottom;        if (width <= height) {            roundPx = width / 2;            top = 0;            bottom = width;            left = 0;            right = width;            height = width;            dst_left = 0;            dst_top = 0;            dst_right = width;            dst_bottom = width;        } else {            roundPx = height / 2;            float clip = (width - height) / 2;            left = clip;            right = width - clip;            top = 0;            bottom = height;            width = height;            dst_left = 0;            dst_top = 0;            dst_right = height;            dst_bottom = height;        }        Bitmap output = Bitmap.createBitmap(width,                height, Bitmap.Config.ARGB_8888);        Canvas canvas = new Canvas(output);        final int color = 0xff424242;        final Paint paint = new Paint();        final Rect src = new Rect((int) left, (int) top, (int) right, (int) bottom);        final Rect dst = new Rect((int) dst_left, (int) dst_top, (int) dst_right, (int) dst_bottom);        final RectF rectF = new RectF(dst);        paint.setAntiAlias(true);        canvas.drawARGB(0, 0, 0, 0);        paint.setColor(color);        canvas.drawRoundRect(rectF, roundPx, roundPx, paint);        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));        canvas.drawBitmap(bitmap, src, dst, paint);        return output;    }    /**     * 根据Uri获取图片的路径     *     * @param uri     * @param contentResolver     * @return     */    public static File getFileByUri(Uri uri, ContentResolver contentResolver) {        String[] proj = {MediaStore.Images.Media.DATA};        Cursor actualimagecursor = contentResolver.query(uri, proj, null, null, null);        int actual_image_column_index = actualimagecursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);        actualimagecursor.moveToFirst();        String img_path = actualimagecursor.getString(actual_image_column_index);        File file = new File(img_path);        return file;    }    /**     * 图片保存到本地     *     * @param context     * @param bitmap     * @param file     * @return     */    public static boolean saveImageToLocal(Context context, Bitmap bitmap, File file) {        try {            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));            bitmap.compress(Bitmap.CompressFormat.JPEG, 80, bos);            bos.flush();            bos.close();            if (file.exists()) {//判断图片是否保存成功了                return true;            } else {                return false;            }        } catch (Exception e) {            e.printStackTrace();            return false;        }    }}